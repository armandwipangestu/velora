import { visit } from "unist-util-visit"
import type { Root, Element } from "hast"

/**
 * Parses the meta string from a code block and extracts attributes.
 * Example: title="example.tsx" icon="typescript" fontLigatures=true
 */
const parseMeta = (meta: string) => {
    const attributes: Record<string, string> = {}
    
    // Match patterns like key="value" or key=value
    const regex = /([a-zA-Z0-9]+)=("[^"]*"|[^ ]+)/g
    let match
    
    while ((match = regex.exec(meta)) !== null) {
        const key = match[1]
        let value = match[2]
        
        // Remove quotes if present
        if (value.startsWith('"') && value.endsWith('"')) {
            value = value.slice(1, -1)
        }
        
        attributes[key] = value
    }
    
    return attributes
}

export const rehypePreMeta = () => (tree: Root) => {
    visit(tree, "element", (node: Element, index, parent) => {
        if (node.tagName !== "pre") return

        const codeEl = node.children.find(
            (child): child is Element => child.type === "element" && child.tagName === "code"
        )
        if (!codeEl) return

        node.properties = node.properties || {}

        const codeData = codeEl.data as { meta?: string } | undefined
        const meta = codeData?.meta || (codeEl.properties?.meta as string) || ""
        
        const attributes = parseMeta(meta)

        // Mapping of meta keys to data attributes
        const metaMap: Record<string, string> = {
            title: "data-title",
            icon: "data-icon",
            font: "data-font",
            fontLigatures: "data-ligatures",
            iconColor: "data-icon-color",
            caption: "data-caption"
        }

        // Apply extracted attributes to the pre element
        Object.entries(metaMap).forEach(([metaKey, dataAttr]) => {
            if (attributes[metaKey] !== undefined) {
                node.properties![dataAttr] = attributes[metaKey]
            }
        })

        // Set defaults for specific attributes if not provided
        if (attributes.fontLigatures === undefined) {
            node.properties["data-ligatures"] = "true"
        }
        if (attributes.iconColor === undefined) {
            node.properties["data-icon-color"] = "true"
        }

        // Preserve language if present
        const language = node.properties["data-language"] as string || ""
        if (language) {
            node.properties["data-language"] = language
        }

        // If parent is a figure (from rehype-pretty-code), copy properties to it
        if (parent && parent.type === "element" && parent.tagName === "figure") {
            parent.properties = { ...parent.properties, ...node.properties }
        }
    })

    // Remove redundant title elements generated by rehype-pretty-code
    visit(tree, "element", (node: Element, index, parent) => {
        if (node.properties && "data-rehype-pretty-code-title" in node.properties) {
            if (parent && typeof index === "number") {
                parent.children.splice(index, 1)
                return index
            }
        }
    })
}
