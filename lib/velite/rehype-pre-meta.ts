import { visit } from "unist-util-visit"
import type { Root, Element } from "hast"
import { parseMeta } from "./utils"

export const rehypePreMeta = () => (tree: Root) => {
    visit(tree, "element", (node: Element, index, parent) => {
        if (node.tagName !== "pre") return

        const codeEl = node.children.find(
            (child): child is Element => child.type === "element" && child.tagName === "code"
        )
        if (!codeEl) return

        node.properties = node.properties || {}

        // 1. Check if attributes are already on the code element (from remarkExtractMeta)
        // 2. If not, try to parse from meta (for cases where remarkExtractMeta didn't run)
        const codeData = codeEl.data as { meta?: string } | undefined
        const meta = codeData?.meta || (codeEl.properties?.meta as string) || ""
        
        const attributes = parseMeta(meta)

        // Mapping of meta keys to data attributes
        const metaMap: Record<string, string> = {
            title: "data-title",
            icon: "data-icon",
            font: "data-font",
            fontLigatures: "data-ligatures",
            iconColor: "data-icon-color",
            caption: "data-caption"
        }

        // Apply extracted attributes to the pre element
        Object.entries(metaMap).forEach(([metaKey, dataAttr]) => {
            // Priority:
            // 1. Properties already on node (pre)
            // 2. Properties on codeEl (from remarkExtractMeta)
            // 3. Parsed from meta string
            if (node.properties![dataAttr] === undefined) {
                if (codeEl.properties?.[dataAttr] !== undefined) {
                    node.properties![dataAttr] = codeEl.properties[dataAttr]
                } else if (attributes[metaKey] !== undefined) {
                    node.properties![dataAttr] = attributes[metaKey]
                }
            }
        })

        // Set defaults for specific attributes if not provided
        if (node.properties["data-ligatures"] === undefined) {
            node.properties["data-ligatures"] = "true"
        }
        if (node.properties["data-icon-color"] === undefined) {
            node.properties["data-icon-color"] = "true"
        }
    })
}

export const rehypePostMeta = () => (tree: Root) => {
    visit(tree, "element", (node: Element, index, parent) => {
        if (node.tagName !== "pre") return

        // If parent is a figure (from rehype-pretty-code), copy properties to it
        if (parent && parent.type === "element" && parent.tagName === "figure") {
            parent.properties = { ...parent.properties, ...node.properties }
        }
    })

    // Remove redundant title elements generated by rehype-pretty-code
    visit(tree, "element", (node: Element, index, parent) => {
        if (node.properties && "data-rehype-pretty-code-title" in node.properties) {
            if (parent && typeof index === "number") {
                parent.children.splice(index, 1)
                return index
            }
        }
    })
}

